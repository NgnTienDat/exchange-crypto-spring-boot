package com.ntd.exchange_crypto.trade.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.ntd.exchange_crypto.asset.AssetExternalAPI;
import com.ntd.exchange_crypto.market.OrderBookData;
import com.ntd.exchange_crypto.order.OrderDTO;
import com.ntd.exchange_crypto.order.OrderExternalAPI;
import com.ntd.exchange_crypto.order.OrderReceivedEvent;
import com.ntd.exchange_crypto.order.enums.OrderStatus;
import com.ntd.exchange_crypto.order.enums.OrderType;
import com.ntd.exchange_crypto.order.enums.Side;
import com.ntd.exchange_crypto.order.mapper.OrderMapper;
import com.ntd.exchange_crypto.order.model.Order;
import com.ntd.exchange_crypto.trade.OrderBookStatsService;
import com.ntd.exchange_crypto.trade.model.OrderBookStats;
import com.ntd.exchange_crypto.trade.model.Trade;
import lombok.extern.slf4j.Slf4j;

import org.springframework.context.ApplicationEventPublisher;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Component;

import java.math.BigDecimal;
import java.time.Duration;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.TimeUnit;

@Slf4j
@Component
public class MatchEngine {

    private final ApplicationEventPublisher eventPublisher;
    private final TradeService tradeService;
    private final OrderBookStatsService orderBookStatsService;
    private final OrderExternalAPI orderExternalAPI;
    private final RedisTemplate<String, Object> redisTemplate;
    private final ObjectMapper objectMapper;
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);
    private final OrderMapper orderMapper;

    public MatchEngine(TradeService tradeService,
                       OrderBookStatsService orderBookStatsService,
                       OrderExternalAPI orderExternalAPI, AssetExternalAPI assetExternalAPI,
                       AssetExternalAPI assetExternalAPI1, SimpMessagingTemplate messagingTemplate,
                       ApplicationEventPublisher eventPublisher, RedisTemplate<String,
                    Object> redisTemplate, ObjectMapper objectMapper, OrderMapper orderMapper) {
        this.tradeService = tradeService;
        this.orderBookStatsService = orderBookStatsService;
        this.orderExternalAPI = orderExternalAPI;
        this.eventPublisher = eventPublisher;
        this.redisTemplate = redisTemplate;
        this.objectMapper = objectMapper;
        this.orderMapper = orderMapper;
    }


    // l·∫Øng nghe order m·ªõi t·ª´ Redis pub/sub
    public void processNewOrder(Order order) throws JsonProcessingException {
        if (order == null || order.getId() == null) {
            log.error("Received null or invalid order");
            return;
        }
        switch (order.getType()) {
            case MARKET:
                log.info("üî• Nh·∫≠n order m·ªõi: {}", order);
                handleMarketOrder(order);
                break;

            case LIMIT:
                handleLimitOrder(order);
                break;

            default:
                log.warn("Unsupported order type: {}", order.getType());
                break;
        }
    }

    // X·ª≠ l√Ω l·ªánh Market
    private void handleMarketOrder(Order order) throws JsonProcessingException {
        // 1. X√°c ƒë·ªãnh chi·ªÅu l·ªánh (BID ho·∫∑c ASK)
        // 2. L·∫•y bestAsk ho·∫∑c bestBid t·ª´ cache orderBookStatsService
        // 3. L·∫•y order ƒë·ªëi ·ª©ng c√≥ gi√° t·ªët nh·∫•t t·ª´ Redis OrderBook
        // 4. N·∫øu gi√° c·ªßa order ƒë·ªëi ·ª©ng t·ªët h∆°n ho·∫∑c b·∫±ng best gi√° hi·ªán t·∫°i:
        //    - Kh·ªõp l·ªánh v·ªõi order ƒë·ªëi ·ª©ng
        //    - T·∫°o giao d·ªãch th·ª±c v·ªõi user t∆∞∆°ng ·ª©ng
        // 5. N·∫øu kh√¥ng c√≥ order ƒë·ªëi ·ª©ng t·ªët h∆°n:
        //    - Kh·ªõp v·ªõi anonymous user theo best gi√° hi·ªán t·∫°i
        //    - T·∫°o giao d·ªãch v·ªõi user ·∫£o
        // 6. G·ª≠i event t·∫°o giao d·ªãch / l∆∞u v√†o DB

        /*
         * ASK b√°n             BID mua
         * 99                 101
         * 100                100
         * 101                99
         * */


        log.info("üî• Nh·∫≠n order m·ªõi MARKET: {}", order);


        // 1. X√°c ƒë·ªãnh chi·ªÅu l·ªánh (BID ho·∫∑c ASK)
        Side side = order.getSide();
        String productId = this.getPairIdFromOrderBookData(side, order.getGiveCryptoId(), order.getGetCryptoId());

        // 2. L·∫•y stats t·ª´ cache (ƒë√£ c·∫≠p nh·∫≠t li√™n t·ª•c b·ªüi BinanceWebSocketService)
        OrderBookStats stats = orderBookStatsService.getStats(productId);
        if (stats == null) {
            log.warn("No order book (Form Binance) stats available for {}", productId);
            return;
        }

        BigDecimal bestPrice = (side == Side.BID) ? stats.getMinAskPrice() : stats.getMaxBidPrice();
        log.info("üî• Best price for {}: {}", productId, bestPrice);

        String pairId = orderExternalAPI.getPairId(side, order.getGiveCryptoId(), order.getGetCryptoId());

        // 3. T√¨m order ƒë·ªëi ·ª©ng t·ª´ Redis (RedisZSet theo chi·ªÅu ng∆∞·ª£c l·∫°i)
        Side counterSide = (side == Side.BID) ? Side.ASK : Side.BID;
        String redisZSetKey = "orderbook:" + pairId + ":" + counterSide.name().toLowerCase();
        log.info("üî• Redis ZSet key: {}", redisZSetKey);

        // L·∫•y order ƒë·ªëi ·ª©ng c√≥ gi√° t·ªët nh·∫•t t·ª´ Redis
        Set<Object> orderRedis = redisTemplate.opsForZSet().range(redisZSetKey, 0, 0);
        log.info("üî• Order Redis: {}", orderRedis);


        if (orderRedis != null && !orderRedis.isEmpty()) {
            log.info("üî• Found {} order stats", orderRedis.size());

            String counterOrderKey = (String) orderRedis.iterator().next();

            log.info("üî• Found counter order key: {}", counterOrderKey);


//            // 4. Get order details from Redis Hash
            String orderJson = (String) redisTemplate.opsForHash().get("order:" + counterOrderKey, "order");
            if (orderJson == null) return;

            Order counterOrder = objectMapper.readValue(orderJson, Order.class);
            log.info("üî• Counter order: {}", counterOrder);
//
//          // 5. Compare with best price to determine match with user or anonymous
            if ((side == Side.BID && counterOrder.getPrice().compareTo(bestPrice) <= 0) ||
                    (side == Side.ASK && counterOrder.getPrice().compareTo(bestPrice) >= 0)) {

                // ‚úÖ 6. Kh·ªõp l·ªánh gi·ªØa 2 user
                match(order, counterOrder);
            } else {
                matchWithAnonymous(order, bestPrice, order.getQuantity());
            }
        } else {
            log.warn("No order redis available for {}", redisZSetKey);
            matchWithAnonymous(order, bestPrice, order.getQuantity());
        }

        // 9. G·ª≠i event l∆∞u giao d·ªãch v√†o DB ho·∫∑c x·ª≠ l√Ω h·∫≠u kh·ªõp
    }


    // X·ª≠ l√Ω l·ªánh Limit
    private void handleLimitOrder(Order order) throws JsonProcessingException {
        // 1. X√°c ƒë·ªãnh chi·ªÅu l·ªánh (BID ho·∫∑c ASK)
        // 2. L·∫•y minAsk & maxAsk ho·∫∑c minBid & maxBid t·ª´ cache orderBookStatsService
        // 3. Ki·ªÉm tra c√≥ order ƒë·ªëi ·ª©ng c√πng gi√° trong Redis OrderBook
        //    - N·∫øu c√≥: t·∫°o giao d·ªãch th·ª±c (kh·ªõp to√†n ph·∫ßn / m·ªôt ph·∫ßn)
        //    - N·∫øu kh√¥ng:
        //        + N·∫øu gi√° n·∫±m trong min-max ƒë·ªëi ·ª©ng => delay random 5-30s r·ªìi kh·ªõp v·ªõi anonymous user
        //        + N·∫øu gi√° n·∫±m ngo√†i min-max => ƒë·∫∑t tr·∫°ng th√°i PENDING
        // 4. G·ª≠i event t·∫°o giao d·ªãch ho·∫∑c c·∫≠p nh·∫≠t tr·∫°ng th√°i l·ªánh


        log.info("üî• Nh·∫≠n order m·ªõi LIMIT: {}", order);


        // 1. Determine the side of the order (BID or ASK)
        Side side = order.getSide();
        String productId = this.getPairIdFromOrderBookData(side, order.getGiveCryptoId(), order.getGetCryptoId());

        // 2. Get stats from cache (continuously updated by BinanceWebSocketService)
        OrderBookStats stats = orderBookStatsService.getStats(productId);
        if (stats == null) {
            log.warn("No order book (Form Binance) stats available for {}", productId);
            return;
        }

        BigDecimal minPrice, maxPrice;
        BigDecimal extendRange = BigDecimal.valueOf(500); // Kho·∫£ng m·ªü r·ªông
        if (side == Side.BID) {
            minPrice = stats.getMinAskPrice().subtract(extendRange);
            maxPrice = stats.getMaxAskPrice().add(extendRange);
        } else {
            minPrice = stats.getMinBidPrice().subtract(extendRange);
            maxPrice = stats.getMaxBidPrice().add(extendRange);
        }

        log.info("üî• Best price for {}: {} - {}", productId, minPrice, maxPrice);

        Order matchingOrder = null;
        matchingOrder = findMatchingOrderByPrice(order);

        if (matchingOrder != null) {
            log.info("üî• T√¨m th·∫•y order ƒë·ªëi ·ª©ng c√πng gi√°: {}", matchingOrder);
            match(order, matchingOrder);
        } else {
            log.info("üî• Kh√¥ng t√¨m th·∫•y order ƒë·ªëi ·ª©ng trong Redis");
            // N·∫øu gi√° n·∫±m trong kho·∫£ng min-max
            if (order.getPrice().compareTo(minPrice) >= 0 && order.getPrice().compareTo(maxPrice) <= 0) {
                // Match with anonymous user after a random delay from 5 to 15 seconds
                scheduleAnonymousMatch(order, Duration.ofSeconds(ThreadLocalRandom.current().nextInt(5, 8)));

            } else {
                // Set PENDING
                log.info("üî• Order {} n·∫±m ngo√†i kho·∫£ng gi√° min-max, ƒë·∫∑t tr·∫°ng th√°i PENDING", order.getId());

                order.setStatus(OrderStatus.PENDING);
                orderExternalAPI.updateOrderStatus(order, BigDecimal.ZERO, BigDecimal.ZERO);
                log.info("üî• Order {} ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t tr·∫°ng th√°i PENDING", order.getId());
            }


        }


        // test c√°c tr∆∞·ªùng h·ª£p
        // TH1: Kh·ªõp v·ªõi order ƒë·ªëi ·ª©ng c√πng gi√°
        // TH2: Kh√¥ng c√≥ order ƒë·ªëi ·ª©ng c√πng gi√°, nh∆∞ng gi√° n·∫±m trong kho·∫£ng min-max => kh·ªõp v·ªõi anonymous user
        // TH3: Kh√¥ng c√≥ order ƒë·ªëi ·ª©ng c√πng gi√°, v√† gi√° n·∫±m ngo√†i kho·∫£ng min-max => ƒë·∫∑t tr·∫°ng th√°i PENDING


        // 9. G·ª≠i event l∆∞u giao d·ªãch v√†o DB ho·∫∑c x·ª≠ l√Ω h·∫≠u kh·ªõp;
    }

    // C·∫≠p nh·∫≠t d·ªØ li·ªáu OrderBook t·ª´ Binance (OrderBookData)
    public void updateOrderBookData(OrderBookData data) {
        // 1. C·∫≠p nh·∫≠t bestBid v√† bestAsk v√†o cache
        // 2. C·∫≠p nh·∫≠t min/max c·ªßa BID v√† ASK
        // 3. N·∫øu c√≥ c√°c l·ªánh LIMIT ƒëang PENDING v√† gi√° hi·ªán t·∫°i ƒë√£ v√†o kho·∫£ng min-max
        //    => x√©t v√† t·∫°o giao d·ªãch v·ªõi anonymous user n·∫øu ph√π h·ª£p
    }


    private void match(Order takerOrder, Order makerOrder) {
        // takerOrder: new order v·ª´a nh·∫≠n
        // makerOrder: counter order ƒë√£ t√¨m th·∫•y t·ª´ Redis
        // N·∫øu makerOrder c√≥ side l√† BID th√¨ isBuyerMaker = true
        System.out.println("üî• Kh·ªõp l·ªánh: Taker Order: " + takerOrder + ", \nMaker Order: " + makerOrder);

        BigDecimal matchPrice = makerOrder.getPrice();
        BigDecimal matchQuantity = takerOrder.getQuantity().min(makerOrder.getQuantity());
        boolean isBuyerMaker = makerOrder.getSide() == Side.BID;

        // 1. T·∫°o b·∫£n ghi Transaction (Giao d·ªãch)
        Trade trade = Trade.builder()
                .takerOrderId(takerOrder.getId())
                .makerOrderId(makerOrder.getId())
                .productId(orderExternalAPI.getPairId(takerOrder.getSide(), takerOrder.getGiveCryptoId(), takerOrder.getGetCryptoId()))
                .price(makerOrder.getPrice())
                .quantity(matchQuantity)
                .isBuyerMaker(isBuyerMaker)
                .build();
        // L∆∞u giao d·ªãch v√†o DB (ho·∫∑c g·ª≠i event ƒë·ªÉ l∆∞u sau)?
        tradeService.saveTrade(trade);
        log.info("üî• ƒê√£ t·∫°o giao d·ªãch: {}", trade);


        // 2. C·∫≠p nh·∫≠t l·∫°i Order c·ªßa c·∫£ hai b√™n (gi·∫£m quantity, status...)
        //   - N·∫øu quantity b·∫±ng nhau th√¨ c·∫£ hai ƒë·ªÅu l√† FILLED
        //   - N·∫øu order n√†o c√≥ quantity nh·ªè h∆°n th√¨ c·∫≠p nh·∫≠t status l√† FILLED
        //   - Ng∆∞·ª£c l·∫°i order l·ªõn h∆°n c√≤n l·∫°i s·∫Ω l√† PARTIALLY_FILLED
        //   - C·∫≠p nh·∫≠t l·∫°i quantity ƒë√£ kh·ªõp (quantityFilled) cho c·∫£ hai order
        //   - C·∫≠p nh·∫≠t l·∫°i tr·∫°ng th√°i c·ªßa c·∫£ hai order
        if (takerOrder.getQuantity().compareTo(makerOrder.getQuantity()) == 0) {
            takerOrder.setStatus(OrderStatus.FILLED);
            makerOrder.setStatus(OrderStatus.FILLED);

        } else if (takerOrder.getQuantity().compareTo(makerOrder.getQuantity()) < 0) {
            // Taker order nh·ªè h∆°n => taker l√† FILLED, maker l√† PARTIALLY_FILLED
            takerOrder.setStatus(OrderStatus.FILLED);
            makerOrder.setStatus(OrderStatus.PARTIALLY_FILLED);
        } else {
            // Maker order nh·ªè h∆°n => maker l√† FILLED, taker l√† PARTIALLY_FILLED
            makerOrder.setStatus(OrderStatus.FILLED);
            takerOrder.setStatus(OrderStatus.PARTIALLY_FILLED);
        }
        log.info("üî• C·∫≠p nh·∫≠t tr·∫°ng th√°i order");
        if (takerOrder.getType() == OrderType.MARKET) {
            takerOrder.setPrice(matchPrice); // C·∫≠p nh·∫≠t gi√° kh·ªõp
        }
        orderExternalAPI.updateOrderStatus(takerOrder, matchQuantity, matchPrice);
        orderExternalAPI.updateOrderStatus(makerOrder, matchQuantity, matchPrice);


        OrderDTO orderDtoTaker = OrderDTO.builder()
                .id(takerOrder.getId())
                .userId(takerOrder.getUserId())
                .pairId(orderExternalAPI.getPairId(takerOrder.getSide(), takerOrder.getGiveCryptoId(), takerOrder.getGetCryptoId()))
                .side(takerOrder.getSide().name())
                .type(takerOrder.getType().name())
                .quantity(takerOrder.getQuantity())
                .price(takerOrder.getPrice())
                .status(takerOrder.getStatus().name())
                .filledQuantity(takerOrder.getFilledQuantity())
                .build();

        OrderDTO orderDtoMaker = OrderDTO.builder()
                .id(makerOrder.getId())
                .userId(makerOrder.getUserId())
                .pairId(orderExternalAPI.getPairId(takerOrder.getSide(), takerOrder.getGiveCryptoId(), takerOrder.getGetCryptoId()))
                .side(makerOrder.getSide().name())
                .type(makerOrder.getType().name())
                .quantity(takerOrder.getQuantity())
                .price(takerOrder.getPrice())
                .status(makerOrder.getStatus().name())
                .filledQuantity(takerOrder.getFilledQuantity())
                .build();

        eventPublisher.publishEvent(new OrderReceivedEvent(orderDtoTaker));
        eventPublisher.publishEvent(new OrderReceivedEvent(orderDtoMaker));

    }

    // H√†m kh·ªõp v·ªõi anonymous user
    private void matchWithAnonymous(Order takerOrder, BigDecimal matchPrice, BigDecimal matchQuantity) {
        log.info("üî• Kh·ªõp l·ªánh v·ªõi anonymous user: Order: {}, Price: {}, Quantity: {}", takerOrder, matchPrice, matchQuantity);

        // 1. T·∫°o Transaction v·ªõi user ·∫£o
        // 2. ƒê√°nh d·∫•u order ƒë√£ kh·ªõp
        // 3. G·ª≠i event kh·ªõp l·ªánh


        boolean isBuyerMaker = takerOrder.getSide() == Side.BID;

        String ANONYMOUS_ORDER_ID = "anonymous-order";
        Trade trade = Trade.builder()
                .takerOrderId(takerOrder.getId())
                .makerOrderId(ANONYMOUS_ORDER_ID)
                .productId(orderExternalAPI.getPairId(takerOrder.getSide(), takerOrder.getGiveCryptoId(), takerOrder.getGetCryptoId()))
                .price(matchPrice)
                .quantity(matchQuantity)
                .isBuyerMaker(isBuyerMaker)
                .build();

        tradeService.saveTrade(trade);
        log.info("üî• ƒê√£ t·∫°o giao d·ªãch v·ªõi anonymous user: {}", trade);
        // Giao d·ªãch v·ªõi anonymous user lu√¥n l√† FILLED
        takerOrder.setStatus(OrderStatus.FILLED);
        orderExternalAPI.updateOrderStatus(takerOrder, matchQuantity, matchPrice);

        OrderDTO orderDtoTaker = OrderDTO.builder()
                .id(takerOrder.getId())
                .userId(takerOrder.getUserId())
                .pairId(orderExternalAPI.getPairId(takerOrder.getSide(), takerOrder.getGiveCryptoId(), takerOrder.getGetCryptoId()))
                .side(takerOrder.getSide().name())
                .type(takerOrder.getType().name())
                .quantity(takerOrder.getQuantity())
                .price(takerOrder.getPrice())
                .status(takerOrder.getStatus().name())
                .filledQuantity(takerOrder.getFilledQuantity())
                .build();
        eventPublisher.publishEvent(new OrderReceivedEvent(orderDtoTaker));

    }

    // H√†m delay kh·ªõp v·ªõi anonymous sau 5-30s
    private void scheduleAnonymousMatch(Order order, Duration delay) {
        // 1. S·ª≠ d·ª•ng ScheduledExecutorService ho·∫∑c TaskScheduler ƒë·ªÉ delay
        // 2. Sau delay, ki·ªÉm tra l·∫°i kho·∫£ng gi√° v√† kh·ªõp n·∫øu h·ª£p l·ªá
        scheduler.schedule(() -> {
            try {

                log.info("‚è≥ Kh·ªõp anonymous cho order {} sau {} gi√¢y", order.getId(), delay.toSeconds());

                // Ki·ªÉm tra l·∫°i gi√° tr∆∞·ªõc khi kh·ªõp (tr√°nh kh·ªõp sai khi th·ªã tr∆∞·ªùng ƒë√£ thay ƒë·ªïi)
                Order matchingOrder = findMatchingOrderByPrice(order);
                if (matchingOrder != null) {
                    log.info("üî• T√¨m th·∫•y order ƒë·ªëi ·ª©ng trong l√∫c delay: {}", matchingOrder);
                    match(order, matchingOrder);
                } else {
                    // N·∫øu v·∫´n kh√¥ng c√≥ order th·∫≠t => kh·ªõp v·ªõi anonymous user
                    log.info("üî• Kh·ªõp v·ªõi anonymous user");
                    log.info("üî•Kh·ªõp v·ªõi anonymous user (Kh√¥ng t√¨m th·∫•y order ƒë·ªëi ·ª©ng");
                    matchWithAnonymous(order, order.getPrice(), order.getQuantity());
                }


            } catch (Exception e) {
                e.printStackTrace();
            }
        }, delay.toMillis(), TimeUnit.MILLISECONDS);

    }

    // H√†m ki·ªÉm tra order limit PENDING c√≥ n√™n kh·ªõp v·ªõi anonymous kh√¥ng
    private void checkPendingOrdersAgainstOrderBook() {
        // 1. L·∫•y danh s√°ch c√°c order LIMIT c√≥ tr·∫°ng th√°i PENDING
        // 2. So s√°nh kho·∫£ng gi√° hi·ªán t·∫°i v·ªõi price c·ªßa t·ª´ng order
        // 3. N·∫øu v√†o v√πng min-max => kh·ªõp v·ªõi anonymous user
    }


    /*--------------- H√†m ti·ªán √≠ch -------------------------------------------------------------------------------*/


    public String getPairIdFromOrderBookData(Side side, String giveCryptoId, String getCryptoId) {
        return side == Side.BID ?
                getCryptoId + giveCryptoId :
                giveCryptoId + getCryptoId;
    }

    private Order findMatchingOrderByPrice(Order order) throws JsonProcessingException {
        // Determining the counter side based on the order side
        Side counterSide = (order.getSide() == Side.BID) ? Side.ASK : Side.BID;
        String pairId = orderExternalAPI.getPairId(order.getSide(), order.getGiveCryptoId(), order.getGetCryptoId());
        String redisZSetKey = "orderbook:" + pairId + ":" + counterSide.name().toLowerCase();

        // Calculate the price part based on the order side
        double pricePart = (counterSide == Side.BID)
                ? -order.getPrice().doubleValue()
                : order.getPrice().doubleValue();

        // Determine the score range for the search
        // Using a small epsilon to allow for slight variations in price matching
        double epsilon = 0.5;
        double scoreMin = pricePart - epsilon;
        double scoreMax = pricePart + epsilon;

        System.out.println("üî• T√¨m ki·∫øm order ƒë·ªëi ·ª©ng trong Redis ZSet: " + redisZSetKey +
                ", Score Min: " + scoreMin + ", Score Max: " + scoreMax);

        // Fetching the matching order from Redis ZSet
        Set<Object> orderRedis = redisTemplate.opsForZSet()
                .rangeByScore(redisZSetKey, scoreMin, scoreMax, 0, 1);

        if (orderRedis != null && !orderRedis.isEmpty()) {
            String counterOrderKey = (String) orderRedis.iterator().next();
            System.out.println("üî• Found counter order key: " + counterOrderKey);

            // Fetching the order details from Redis Hash
            String orderJson = (String) redisTemplate.opsForHash().get("order:" + counterOrderKey, "order");
            if (orderJson == null) return null;

            return objectMapper.readValue(orderJson, Order.class);

        }
        return null;
    }


}
